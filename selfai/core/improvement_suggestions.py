"""
Improvement Suggestions Manager (V2 - Proposal System)

Manages improvement proposals generated by SelfAI analysis.
Supports JSON serialization/deserialization and robust parsing.
"""

from dataclasses import dataclass, asdict, field
from typing import List, Optional, Any
from pathlib import Path
import json
import re

@dataclass
class ImprovementProposal:
    """
    A concrete improvement proposal derived from code analysis.
    Matches the structure defined in SELFIMPROVE_PROPOSAL_SYSTEM.md.
    """
    id: int
    title: str
    description: str
    files: List[str]
    effort_minutes: int
    impact_percent: int
    implementation_steps: List[str]
    priority: str = "medium"  # high, medium, low

    def to_dict(self):
        return asdict(self)

    @property
    def formatted_impact(self) -> str:
        return f"+{self.impact_percent}%"

    @property
    def formatted_effort(self) -> str:
        return f"{self.effort_minutes} Min"


class ImprovementManager:
    """Manages the lifecycle of improvement proposals for a session."""

    def __init__(self):
        self.proposals: List[ImprovementProposal] = []
        self.current_goal: Optional[str] = None

    def clear(self):
        self.proposals = []
        self.current_goal = None

    def add_proposals(self, proposals: List[ImprovementProposal]):
        self.proposals.extend(proposals)

    def get_by_id(self, p_id: int) -> Optional[ImprovementProposal]:
        for p in self.proposals:
            if p.id == p_id:
                return p
        return None

    def get_all(self) -> List[ImprovementProposal]:
        return self.proposals

    def save_to_file(self, filepath: Path):
        """Save current proposals to JSON file."""
        data = {
            "goal": self.current_goal,
            "proposals": [p.to_dict() for p in self.proposals]
        }
        filepath.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding='utf-8')


def parse_proposals_from_json(json_str: str) -> List[ImprovementProposal]:
    """
    Parses the LLM response which should be a JSON object containing a list of proposals.
    Handles potential markdown code block wrapping.
    """
    # Clean up markdown code blocks if present
    cleaned = json_str.strip()
    
    # Remove markdown code fences
    if "```" in cleaned:
        # Match content between ```json (optional) and ```
        match = re.search(r'```(?:json)?\s*(.*?)\s*```', cleaned, re.DOTALL)
        if match:
            cleaned = match.group(1)
        else:
            # Fallback cleanup
            lines = cleaned.splitlines()
            if lines[0].strip().startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].strip().startswith("```"):
                lines = lines[:-1]
            cleaned = "\n".join(lines)

    try:
        data = json.loads(cleaned)
        
        # Handle flexibility in root key
        items = []
        if isinstance(data, list):
            items = data
        elif isinstance(data, dict):
            # Try common keys
            for key in ["proposals", "suggestions", "improvements"]:
                if key in data and isinstance(data[key], list):
                    items = data[key]
                    break
            # If still no items found, maybe the dict IS the item (single proposal)?
            if not items and "title" in data:
                items = [data]
        
        proposals = []
        for i, item in enumerate(items, 1):
            # Ensure ID exists
            p_id = item.get("id")
            if p_id is None:
                p_id = i
            elif isinstance(p_id, str) and p_id.isdigit():
                p_id = int(p_id)
            
            # Normalize fields
            proposals.append(ImprovementProposal(
                id=p_id,
                title=item.get("title", "Untitled Improvement"),
                description=item.get("description", ""),
                files=item.get("files", []),
                effort_minutes=item.get("effort_minutes", 15),
                impact_percent=item.get("impact_percent", 10),
                implementation_steps=item.get("implementation_steps", []),
                priority=item.get("priority", "medium")
            ))
            
        return proposals

    except json.JSONDecodeError as e:
        # Return empty list on failure, caller should handle fallback
        print(f"DEBUG: JSON Parse Error: {e}")
        print(f"DEBUG: Failed content: {cleaned[:200]}...")
        return []